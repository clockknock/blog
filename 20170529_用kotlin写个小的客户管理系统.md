随着Google爸爸把Kotlin加进了Android开发官方支持语言,大家感觉都挺爆炸的,我同样也感觉挺爆炸的,看了几天入门,感觉很爽,想自己也跟着玩玩,但最近不写Android,在学习玩后台,那反正大家都是JVM上跑,我就在写后台来联系Kotlin吧,还在入门阶段,如果有人看到了这篇东西,你有可以教我的东西希望你能教我,先谢谢了!



## 搭建环境

### 创建模块

写Android的时候用AS觉得十分爽,来写后台还是用一个公司的工具IDEA吧,有AS的基础,上手十分快,高兴

新建一个模块配置一下需要的东西:

Module SDK:1.8

JavaEE version:Java EE 7

Application Server:Tomcat 7.0.57

然后选择需要的库和框架,我选了我之前学的:

Web Application,Hibernate,然后必不可少的还有Kotlin(Java)

需要的环境内容搭好就下一步下一步下一步Finish给个模块名把模块创建出来吧



### 建包建类

模块创建后,进到src先把一些可能用到的包和基类Servlet给创建出来



![init_package](F:\JAVAEE_study\blog\img_20170529\init_package.png)



包建好了把service方法重写一下:

```kotlin
//基类管理所有子类的方法
open class BaseServlet : HttpServlet() {

    override fun service(req: HttpServletRequest?, resp: HttpServletResponse?) {
        //!!表明非空&&处理乱码问题
        req!!.characterEncoding = "UTF-8"
        resp!!.contentType = "text/html;charset=UTF-8"

        val methodName = req.getParameter("method")

        val clazz = this.javaClass

        val method = clazz.getMethod(methodName, HttpServletRequest::class.java, HttpServletResponse::class.java)
        val path = method.invoke(this, req, resp) as String

            req.getRequestDispatcher(path).forward(req, resp)

    }
}
```

边分析边学习吧,本来拿kotlin来写东西就是为了学习它:

kotlin在继承了java类后能自动把get/set方法声明成成员变量拿来直接使用,简洁了很多,所以直接调用req.characterEncoding能直接更改req的字符集编码

在上面的代码中有一个java里没见过的操作符"!!"(是该说是操作符吗?),我刚开始在IDEA的EDU Kotlin里学Kotlin时,里面有个题目出现了一个方法,它有一个参数返回后面有"!!",当时还不知道什么意思,在自己使用的时候通过IDEA的提示知道了"!!"的意思:

```kotlin
 //req.characterEncoding = "UTF-8"//直接调用会编译期报错,会提示让你检查空,要么以"req!!"的形式来声明该变量为non-null,要么以"req?"的形式声明安全判断,我就选择了非空声明的形式
 resp!!.contentType = "text/html;charset=UTF-8"
```



### 写个Servlet测试

简简单单建个kotlin类跑个方法

```kotlin
@WebServlet("/userServlet")
class UserServlet :BaseServlet(){
    fun register(request: HttpServletRequest,response: HttpServletResponse){
        val username=request.getParameter("username")
        val password=request.getParameter("password")
        
        println("username is$username and password is $password")
    }
}
```



再简单来个表单提交内容

```jsp
<form action="${pageContext.request.contextPath}/userServlet?method=user&method=register" method="post">
    <table>
        用户名: <input type="text" name="username" placeholder="请输入用户名"/><br/>
        密码: <input type="password" name="password"/><br>
        <input type="submit" value="提交">

    </table>
    <a href="/userServlet">访问userServlet(kotlin)</a>
</form>

```



感觉没啥问题了,跑一跑试试吧:

![start_server](F:\JAVAEE_study\blog\img_20170529\start_server.png)



跑起来以为没啥问题的我一看Output,报了一堆错,这也算是踩到的第一个坑:

![kotlin_typecastexception](F:\JAVAEE_study\blog\img_20170529\kotlin_typecastexception.png)



说是catalina的WebappClassLoader调用加载类时出了一个类型转换异常,诶?不是说kotlin和java是无缝兼容,百分百好用么?初步判断是kotlin这个类没知道,一下子也想不到怎么解决

搜了一下,说是没有kotlin的runtime library导致的,但我创建工程的时候不是选择了Kotlin(java)的lib或环境了么?

跑进Project Structure看了眼,的的确确也有,但为什么还是不行呢?![structrue_kotlinlib](F:\JAVAEE_study\blog\img_20170529\structrue_kotlinlib.png)

目测是tomcat自己跑的时候还没拿到模块依赖的KotlinJavaRuntime,那就找一下kotlinruntime的lib包,但项目放到tomcat后不是会一起编译么?有点搞不懂,先扔到tomcat试试吧

我把觉得有可能有用的kotlin-reflect.jar和kotlin-runtime.jar扔到了tomcat的lib文件夹下,再次运行tomcat,好的,运行没报错了!

(上面这个问题解决了,并不需要将kotlin-reflect.jar和kotlin-runtime.jar放到tomcat的lib文件夹中,在上图左边的Problems里有提示,将未依赖的lib add to Artifacts就行了,但我这不是在Dependencies按步骤添加的lib么?怎么还会有这个问题,初用IDEA踩坑真爽...)



运行没错开始试着提交数据看能不能拿到:

结果还是报了个错

```
kotlin.TypeCastException: null cannot be cast to non-null type kotlin.String
	at com.itheima.cm.web.BaseServlet.service(BaseServlet.kt:27)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(Appl
```

这个错我看着就高兴,以前java没有的嘛,这个不就是kotlin宣传卖点的非空安全性检查嘛,我又回到了代码看我的内容,因为我的这个register方法并没有返回一个String,而在baseServlet中又没有对接收到的数据进行非空校验,所以就出了这个问题,这时候我就回到了我的baseServlet更改代码:

```kotlin
  val path = method.invoke(this, req, resp) as String?

        if (path != null)
            req.getRequestDispatcher(path).forward(req, resp)
    }
```

我将需要	请求转发的路径进行了可为空声明,那这下再自己判断一下就能防止path为null了

(但通过invoke得到值的时候编译器没有让我们校验返回值是否空,这算是一个没考虑好的地方?因为前面在通过req,resp获取值的时候编译器也有提示编译时错误让我们检查null嘛)



## Hibernate测试

### 创建Hibernate配置



IDEA好像不能通过创建好的bean直接生成对应的config,我就直接复制了一份以前的改改需要参数拿来用了

```xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>

    <session-factory>
        <!--四个基本参数-->
        <property name="connection.url">jdbc:mysql://localhost:3306/day01hibernate</property>
        <property name="connection.driver_class">com.mysql.jdbc.Driver</property>
        <property name="connection.username">root</property>
        <property name="connection.password">123</property>

        <!--数据库方言-->
        <property name="dialect">org.hibernate.dialect.MySQL5Dialect</property>

        <!--别的一些配置-->
        <property name="show_sql">true</property>
        <property name="format_sql">true</property>
        <property name="hbm2ddl.auto">create</property>
        <property name="current_session_context_class">thread</property>

        <mapping resource="com/itheima/cm/bean/Customer.hbm.xml"/>

        <!-- DB schema will be updated if needed -->
    </session-factory>
</hibernate-configuration>
```



### 写HibernateUtil

Util一般都是静态方法直接调用,在kotlin里好像并没有静态方法可用,可以使用companion object,在里面写方法来直接调用;

还可以直接使用object关键字定义一个类?里面的方法也是可以通过类名.的方式直接调用

这两者的区别我没翻到文档看,//TODO

```kotlin

object HibernateUtil {

    var factory = Configuration().configure().buildSessionFactory()!!

    fun getSession(): Session {
        return factory.currentSession
    }
}

//class HibernateUtil {
//    companion object {
//        var factory = Configuration().configure().buildSessionFactory()!!
//        fun getSession(): Session {
//            return factory.currentSession
//        }
//    }
//}

```



### 创建POJO

简单一行创建data类就搞定,舒舒服服不用自己写&不用自己生成toString,get/set,equals

```kotlin
data class Customer(var u_name: String, var u_password: String, var u_id: Int)
```

把xxx.hbm.xml也配置一下

```xml
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>

    <class name="com.itheima.cm.bean.Customer" table="t_customer" >
        <id name="u_id"  >
            <column name="U_ID"/>
            <generator class="native"/>
        </id>
        <property name="u_name" column="U_NAME"/>
        <property name="u_password" column="U_AGE"/>
    </class>
</hibernate-mapping>
```

我在IDEA里table/column有报红色,也不知道是为啥,回头再查查,希望如果看到的朋友知道怎么弄也谢谢指教!//TODO





### 进行保存测试

回到我们的servlet创建对象时会报错,说我没初始化对象,回头一看刚刚写的data class Customer,对哦,后面的三个参数就是构造方法,但好像我们以前一般都是先创建对象再调用set方法来给对象赋值,那现在这该怎么办呢?

```kotlin
var ustomer = Customer()
```

回到我们的POJO,给构造函数赋一些默认值

```kotlin
data class Customer(var u_name: String?=null, var u_password: String?=null, var u_id: Int?=null)
```

在构造函数中给了各个属性的默认值后,那么我们新建对象的时候就可以不给变量赋值了,但做到这里的时候我也有点疑惑,默认值应该给什么呢?在java中,我们一个空参构造是不会对成员变量赋值的,那么只是声明了出来,那想必应该都是null?String为null没问题了,那Int类型的呢?在kotlin中,Int是引用类型还是基本类型呢?我试了试可以给null,那kotlin中Int应该就直接是引用类型了吧,也懒得看文档,先这么试试再说





一顿操作把service/dao相关东西搞完,测试一下

![hibernate_init_success](F:\JAVAEE_study\blog\img_20170529\hibernate_init_success.png)



![hibernate_init_success](F:\JAVAEE_study\blog\img_20170529\save_success.png)

好的,插进去了,初步搞定

(未完,待续?)

