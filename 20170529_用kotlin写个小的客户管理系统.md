随着Google爸爸把Kotlin加进了Android开发官方支持语言,大家感觉都挺爆炸的,我同样也感觉挺爆炸的,看了几天入门,感觉很爽,想自己也跟着玩玩,但最近不写Android,在学习玩后台,那反正大家都是JVM上跑,我就在写后台来联系Kotlin吧,还在入门阶段,如果有人看到了这篇东西,你有可以教我的东西希望你能教我,先谢谢了!



## 搭建环境

### 创建模块

写Android的时候用AS觉得十分爽,来写后台还是用一个公司的工具IDEA吧,有AS的基础,上手十分快,高兴

新建一个模块配置一下需要的东西:

Module SDK:1.8

JavaEE version:Java EE 7

Application Server:Tomcat 7.0.57

然后选择需要的库和框架,我选了我之前学的:

Web Application,Hibernate,然后必不可少的还有Kotlin(Java)

需要的环境内容搭好就下一步下一步下一步Finish给个模块名把模块创建出来吧



### 建包建类

模块创建后,进到src先把一些可能用到的包和基类Servlet给创建出来



![init_package](F:\JAVAEE_study\blog\img_20170529\init_package.png)



包建好了把service方法重写一下:

```kotlin
//基类管理所有子类的方法
open class BaseServlet : HttpServlet() {

    override fun service(req: HttpServletRequest?, resp: HttpServletResponse?) {
        //!!表明非空&&处理乱码问题
        req!!.characterEncoding = "UTF-8"
        resp!!.contentType = "text/html;charset=UTF-8"

        val methodName = req.getParameter("method")

        val clazz = this.javaClass

        val method = clazz.getMethod(methodName, HttpServletRequest::class.java, HttpServletResponse::class.java)
        val path = method.invoke(this, req, resp) as String

            req.getRequestDispatcher(path).forward(req, resp)

    }
}
```

边分析边学习吧,本来拿kotlin来写东西就是为了学习它:

kotlin在继承了java类后能自动把get/set方法声明成成员变量拿来直接使用,简洁了很多,所以直接调用req.characterEncoding能直接更改req的字符集编码

在上面的代码中有一个java里没见过的操作符"!!"(是该说是操作符吗?),我刚开始在IDEA的EDU Kotlin里学Kotlin时,里面有个题目出现了一个方法,它有一个参数返回后面有"!!",当时还不知道什么意思,在自己使用的时候通过IDEA的提示知道了"!!"的意思:

```kotlin
 //req.characterEncoding = "UTF-8"//直接调用会编译期报错,会提示让你检查空,要么以"req!!"的形式来声明该变量为non-null,要么以"req?"的形式声明安全判断,我就选择了非空声明的形式
 resp!!.contentType = "text/html;charset=UTF-8"
```



### 写个Servlet测试

简简单单建个kotlin类跑个方法

```kotlin
@WebServlet("/userServlet")
class UserServlet :BaseServlet(){
    fun register(request: HttpServletRequest,response: HttpServletResponse){
        val username=request.getParameter("username")
        val password=request.getParameter("password")
        
        println("username is$username and password is $password")
    }
}
```



再简单来个表单提交内容

```jsp
<form action="${pageContext.request.contextPath}/userServlet?method=user&method=register" method="post">
    <table>
        用户名: <input type="text" name="username" placeholder="请输入用户名"/><br/>
        密码: <input type="password" name="password"/><br>
        <input type="submit" value="提交">

    </table>
    <a href="/userServlet">访问userServlet(kotlin)</a>
</form>

```



感觉没啥问题了,跑一跑试试吧:

![start_server](F:\JAVAEE_study\blog\img_20170529\start_server.png)



跑起来以为没啥问题的我一看Output,报了一堆错,这也算是踩到的第一个坑:

![kotlin_typecastexception](F:\JAVAEE_study\blog\img_20170529\kotlin_typecastexception.png)



说是catalina的WebappClassLoader调用加载类时出了一个类型转换异常,诶?不是说kotlin和java是无缝兼容,百分百好用么?初步判断是kotlin这个类没知道,一下子也想不到怎么解决

搜了一下,说是没有kotlin的runtime library导致的,但我创建工程的时候不是选择了Kotlin(java)的lib或环境了么?

跑进Project Structure看了眼,的的确确也有,但为什么还是不行呢?![structrue_kotlinlib](F:\JAVAEE_study\blog\img_20170529\structrue_kotlinlib.png)

目测是tomcat自己跑的时候还没拿到模块依赖的KotlinJavaRuntime,那就找一下kotlinruntime的lib包,但项目放到tomcat后不是会一起编译么?有点搞不懂,先扔到tomcat试试吧

我把觉得有可能有用的kotlin-reflect.jar和kotlin-runtime.jar扔到了tomcat的lib文件夹下,再次运行tomcat,好的,运行没报错了!

(上面这个问题解决了,并不需要将kotlin-reflect.jar和kotlin-runtime.jar放到tomcat的lib文件夹中,在上图左边的Problems里有提示,将未依赖的lib add to Artifacts就行了,但我这不是在Dependencies按步骤添加的lib么?怎么还会有这个问题,初用IDEA踩坑真爽...)



运行没错开始试着提交数据看能不能拿到:

结果还是报了个错

```
kotlin.TypeCastException: null cannot be cast to non-null type kotlin.String
	at com.itheima.cm.web.BaseServlet.service(BaseServlet.kt:27)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(Appl
```

这个错我看着就高兴,以前java没有的嘛,这个不就是kotlin宣传卖点的非空安全性检查嘛,我又回到了代码看我的内容,因为我的这个register方法并没有返回一个String,而在baseServlet中又没有对接收到的数据进行非空校验,所以就出了这个问题,这时候我就回到了我的baseServlet更改代码:

```kotlin
  val path = method.invoke(this, req, resp) as String?

        if (path != null)
            req.getRequestDispatcher(path).forward(req, resp)
    }
```

我将需要	请求转发的路径进行了可为空声明,那这下再自己判断一下就能防止path为null了

(但通过invoke得到值的时候编译器没有让我们校验返回值是否空,这算是一个没考虑好的地方?因为前面在通过req,resp获取值的时候编译器也有提示编译时错误让我们检查null嘛)



## Hibernate测试



一顿操作把hibernate相关操作搞完,测试一下

![hibernate_init_success](F:\JAVAEE_study\blog\img_20170529\hibernate_init_success.png)

好的,插进去了,搞定

(未完,待续?)

